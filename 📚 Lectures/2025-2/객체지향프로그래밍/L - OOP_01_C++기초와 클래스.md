# C++ 기초와 클래스

## 1. 네임스페이스 (Namespace)

### 개념
- **이름 충돌 방지**를 위해 식별자들을 고유한 영역으로 묶는 기능
- 모든 식별자가 각각 고유하도록 보장하는 영역 설정

### 문법
```cpp
namespace blabla {
    // some_code - 이 안의 모든 이름은 blabla 이름공간에 속함
}

// 사용법
blabla::function();  // 명시적 접근
using namespace blabla;  // using 지시자로 생략 가능
```

### 주요 포인트
- `std::`는 `<iostream>` 헤더파일에 선언된 모든 이름들의 이름공간
- 전역 namespace는 `using` 없이 항상 사용 가능

---

## 2. 클래스와 객체

### 핵심 개념
| 용어 | 설명 |
|------|------|
| **클래스** | 객체를 찍어내는 설계도/틀 (blueprint) |
| **객체** | 클래스에서 찍어낸 실체화된 인스턴스 |
| **멤버 변수** | 객체의 속성/데이터 (사람의 특징/상태) |
| **멤버 함수** | 객체가 할 수 있는 기능 (사람의 행동) |

### 캡슐화 (Encapsulation)
- 객체를 캡슐로 감싸 외부로부터 보호
- 내부에 대한 접근을 제한

### 클래스 선언 문법
```cpp
class 클래스이름 {
접근지정자:  // public, private(디폴트), protected
    클래스이름();               // 생성자
    클래스이름(매개변수);       // 매개변수 있는 생성자
    ~클래스이름();              // 소멸자
    멤버변수 선언;
    멤버함수 선언;
};  // 세미콜론 필수!

// 멤버함수 외부 구현 (범위 지정 연산자 :: 사용)
리턴타입 클래스이름::멤버함수() {
    return 멤버함수 기능;
}

// 객체 생성 및 사용
클래스이름 객체이름;
객체이름.멤버변수 = 값;
객체이름.멤버함수();
```

---

## 3. 접근 지정자 (Access Specifiers)

| 지정자 | 접근 범위 | 비고 |
|--------|----------|------|
| `private` | 동일 클래스 내 멤버함수에서만 | class 디폴트 |
| `public` | 모든 객체, 클래스에서 허용 | struct 디폴트 |
| `protected` | 클래스 자신과 상속 클래스에 허용 | |

> **Best Practice**: 멤버변수는 `private`로 보호하는 것이 바람직

---

## 4. 생성자와 소멸자

### 생성자 (Constructor)
- 객체 생성 시점에 **자동 호출**되는 멤버함수
- 클래스 이름과 동일, **리턴타입 없음**
- 객체 초기화 목적
- **중복 가능** (오버로딩)
- 선언 안 하면 컴파일러가 디폴트 생성자 자동 생성

### 소멸자 (Destructor)
- 객체 소멸 시 **자동 호출**
- 메모리 해제 등 마무리 작업 담당
- `~클래스이름()` 형태
- **중복 불가능**, 매개변수 없음
- 선언 안 하면 자동 생성

### 생성/소멸 순서 (LIFO)
```
생성: obj1 → obj2 → obj3
소멸: obj3 → obj2 → obj1 (역순!)
```

> **주의**: `new`로 동적 생성한 객체는 반드시 `delete`로 소멸자 호출해야 함

---

## 5. 구조체 vs 클래스

| 구분 | struct | class |
|------|--------|-------|
| 디폴트 접근지정자 | `public` | `private` |
| 기능 | C++ 클래스의 모든 기능 사용 가능 | 동일 |
| 용도 | C 호환성 유지, 단순 데이터 묶음 | 객체 지향 설계 |

---

## 6. 인라인 함수 (Inline Function)

### 오버헤드 문제
함수 호출 시 발생하는 부가 작업:
1. 돌아올 주소 저장 (lr: 링크 레지스터)
2. CPU 레지스터 값 저장
3. 매개변수를 스택에 저장

### 인라인 함수의 해결책
- 함수 호출 대신 **코드를 호출 위치에 직접 삽입**
- 실행 속도 향상, 코드 길이는 증가

### 선언 방법
```cpp
// 명시적 인라인
inline int function(int x) {
    return x * 2;
}

// 자동 인라인 - 클래스 내부에서 정의하면 자동 적용
class MyClass {
    int getValue() { return value; }  // 자동 인라인
};
```

### 인라인 제외 대상
- 재귀 함수
- 길이가 긴 함수
- `static` 함수
- `goto` 문 포함 함수

---

## 7. 열거형 (enum)

관련된 상수들의 집합에 이름을 붙여 가독성 향상

```cpp
// Before - 가독성 떨어짐
const int SUNDAY = 0;
int today = 2;  // 2가 무슨 요일?

// After - enum 사용
enum Day {
    SUNDAY,   // 0
    MONDAY,   // 1
    TUESDAY,  // 2
};
Day today = TUESDAY;  // 명확하고 이해하기 쉬움
```

---

## 8. 헤더 파일과 분리 컴파일

### 파일 분할 구조
```
Circle.h    → 클래스 선언부 (멤버 변수, 함수 원형)
Circle.cpp  → 클래스 구현부 (멤버 함수 구현)
main.cpp    → main() 함수
```

### 컴파일 과정
```
Circle.cpp → [컴파일] → Circle.obj ─┐
                                     ├→ [링킹] → 실행파일(.exe)
main.cpp   → [컴파일] → main.obj   ─┘
```

### 헤더 가드 (중복 include 방지)
```cpp
#ifndef CIRCLE_H
#define CIRCLE_H

// 클래스 선언 코드

#endif
```

### 헤더 포함 방법
```cpp
#include <iostream>   // 표준 라이브러리
#include "myheader.h" // 사용자 정의 헤더
```

---

## 9. 메모리 영역

| 영역 | 저장 내용 |
|------|----------|
| **스택 (Stack)** | 지역 변수, 함수 호출 정보 |
| **힙 (Heap)** | 동적 할당 메모리 (`new`/`delete`) |
| **데이터 (Data)** | 전역 변수, 정적 변수 |
| **코드 (Code)** | 기계어 코드 |

---

## 10. 디버깅 기법

### 컴파일 타임 디버깅
- 구문(syntax) 오류 발생 시
- 컴파일러가 오류 메시지 출력

### 런타임 디버깅
1. **테스트 케이스**: 다양한 입력으로 출력 확인
2. **assert 문**: 조건이 거짓이면 프로그램 중단
   ```cpp
   #include <cassert>
   assert(x > 0);  // x > 0이 아니면 중단
   ```
3. **한 줄씩 실행**: 디버거 활용
4. **로그 기반**: 출력문으로 변수값 확인
