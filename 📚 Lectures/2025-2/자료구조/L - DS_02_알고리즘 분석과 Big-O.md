# 알고리즘 분석과 Big-O

## 1. 알고리즘 분석의 목적

### 왜 분석이 필요한가?
- 하드웨어 독립적인 성능 비교
- 입력 크기 증가에 따른 성능 예측
- 알고리즘 선택의 객관적 기준

### 분석 방법
1. **실험적 분석**: 실제 실행 시간 측정
   - 단점: 하드웨어/OS 의존적, 구현 필요
   
2. **이론적 분석**: Primitive operation 개수 세기
   - 장점: 하드웨어 독립적, 구현 없이 분석 가능

---

## 2. 점근적 표기법 (Asymptotic Notation)

### Big-O (상한, Upper Bound)
> "아무리 오래 걸려도 이 시간보다는 빠르다"

**정의**: f(n) = O(g(n))
- 충분히 큰 n에 대해 f(n) ≤ c·g(n)을 만족하는 상수 c > 0, n₀ ≥ 1이 존재

```
예제: 2n + 10 = O(n)
증명: 2n + 10 ≤ 3n (n ≥ 10일 때)
      c = 3, n₀ = 10
```

### Big-Omega Ω (하한, Lower Bound)
> "아무리 빨라도 최소한 이 정도 시간은 걸린다"

### Big-Theta Θ (정확한 성장률)
> "알고리즘의 성능은 정확히 이 속도로 증가한다"

상한과 하한이 일치하는 경우

---

## 3. 시간 복잡도 7가지

```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ)
```

| 복잡도 | 이름 | 특징 |
|--------|------|------|
| **O(1)** | 상수 | 신의 알고리즘! 입력 크기 무관 |
| **O(log n)** | 로그 | 이진 탐색. 매우 효율적 |
| **O(n)** | 선형 | 입력에 비례 |
| **O(n log n)** | 선형 로그 | 효율적인 정렬 (병합, 퀵) |
| **O(n²)** | 이차 | 이중 반복문 |
| **O(n³)** | 삼차 | 삼중 반복문 |
| **O(2ⁿ)** | 지수 | 저주받은 알고리즘 |

### 성장률 비교표

| n    | log n | n     | n log n | n²        | n³        | 2ⁿ        |
| ---- | ----- | ----- | ------- | --------- | --------- | --------- |
| 10   | 3     | 10    | 33      | 100       | 1,000     | 1,024     |
| 100  | 7     | 100   | 664     | 10,000    | 1,000,000 | 1.27×10³⁰ |
| 1000 | 10    | 1,000 | 9,966   | 1,000,000 | 10⁹       | ...       |

---

## 4. T(n) 증명 문제 공략법

### 3단계 접근법

**예제: T(n) = 3n³ + 20n² + 5 가 O(n³)임을 증명**

**1단계: 부등식 설정**
```
3n³ + 20n² + 5 ≤ c · n³
```

**2단계: 상수 c 결정**
- 최고차항 계수(3)보다 약간 큰 값 선택
- c = 4로 설정

**3단계: 임계점 n₀ 찾기**
```
3n³ + 20n² + 5 ≤ 4n³
20n² + 5 ≤ n³
```
- n = 21부터 만족
- 따라서 c = 4, n₀ = 21

---

## 5. 알고리즘 예제

### Prefix Average - Quadratic O(n²)
```cpp
void prefixAverages1(int X[], int A[], int n) {
    for (int i = 0; i < n; i++) {          // n번
        int s = X[0];
        for (int j = 1; j <= i; j++) {     // 1+2+...+n
            s += X[j];
        }
        A[i] = s / (i + 1);
    }
}
// 시간: 1 + 2 + ... + n = n(n+1)/2 = O(n²)
```

### Prefix Average - Linear O(n)
```cpp
void prefixAverages2(int X[], int A[], int n) {
    int s = 0;
    for (int i = 0; i < n; i++) {          // n번
        s += X[i];                         // 누적 합
        A[i] = s / (i + 1);
    }
}
// 시간: O(n)
```

---

## 6. 재귀의 시간 복잡도

### 피보나치 (단순 재귀) - O(2^n)
```cpp
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 중복 계산!
}
// 시간: O(2^(n/2)) ≈ O(2^n) - 매우 비효율적
```

### 피보나치 (동적 프로그래밍) - O(n)
```cpp
int fib(int n) {
    int dp[n+1];
    dp[0] = 0; dp[1] = 1;
    for (int i = 2; i <= n; i++)
        dp[i] = dp[i-1] + dp[i-2];
    return dp[n];
}
// 시간: O(n) - 훨씬 효율적
```

### 하노이의 탑 - O(2^n)
```cpp
void hanoi(int n, char from, char to, char aux) {
    if (n == 1) {
        move(from, to);
        return;
    }
    hanoi(n-1, from, aux, to);
    move(from, to);
    hanoi(n-1, aux, to, from);
}
// T(n) = 2T(n-1) + 1 = 2^n - 1 = O(2^n)
```

---

## 7. 시험 대비 팁

### Big-O 증명 문제 체크리스트
- [ ] c와 n₀를 구체적으로 제시
- [ ] 부등식이 n ≥ n₀에서 성립함을 보임
- [ ] 가능한 작은 c와 n₀ 사용 (타이트한 증명)

### 자주 출제되는 형태
1. `T(n) = an² + bn + c` → O(n²)
2. `T(n) = an log n + bn` → O(n log n)
3. `T(n) = 2T(n/2) + n` → O(n log n) [병합 정렬]
4. `T(n) = T(n-1) + n` → O(n²)

### 코드에서 복잡도 파악하기
```cpp
// O(n)
for (int i = 0; i < n; i++) { ... }

// O(n²)
for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++) { ... }

// O(log n)
while (n > 1) { n = n / 2; }

// O(n log n)
for (int i = 0; i < n; i++)
    for (int j = 1; j < n; j *= 2) { ... }
```
