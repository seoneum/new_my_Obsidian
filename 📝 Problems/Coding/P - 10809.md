---
type: problem
title: P - 10809
created: 2026-01-27
updated: 2026-01-27T09:29:14
problem_type: coding
source: baekjoon
difficulty: medium
language: cpp
status: "[[🚜In Progress]]"
solved: false
tags:
  - problem
  - problem/coding
  - difficulty/medium
  - source/baekjoon
---
# 10809

> **coding** | 난이도: **medium** | 출처: baekjoon 10809

---

## 📋 문제

### 입력
```
string 단어.
```

### 출력
```
알파벳 26개 순서대로 -1로 나열되어있고 포함되어있는 글자는 인덱스의 번호 입력
```

### 제한
- 시간: 
- 메모리: 

---

## 🧠 접근

### 첫 생각
- 일단 string으로 받아.
- 그리고 for문을 두번 돌려서 첫번째는 알파벳, 두번째는 안의 단어로 해서 매칭시킴.
- if로 매칭시키면 두다다다닥 ㄷ돼서 할 수 있을듯?

### 핵심 아이디어
- 하지만 이게 아녔죠? 방법은 맞는데 더 빠른 방법이 존재한다! 지금 for문 두 번 쓰면 시간 복잡도 O($n^2$)이잖아. 이러면 손해야
1. 첫 방법은 vector를 사용하는 방법이다.
	- `std::vector<int> v(26,-1)`로 알파벳 개수 26개의 자리, 그 자리를 모두 -1로.
	- for문을 딱 한번 돌아서 그 값이 있으면 index값 삽입. 없으면 그대로.
	- for문으로 출력 갈겨잇!
2. Modern하게
	- views와 pipeline을 활용하자!
	- std::views::iota로 a - z까지의 알파벳 무지성 순서대로 던지기
	- std::views::transform으로 변형
	- ramda함수로 변형시켜야함
	- views::iota에서 던지는 것들을 하나씩 받고 s를 참조.
	- 계산 로직은 s에서 c를 find하라. 찾으면 그 인덱스, 못찾으면 npos를 반환하는데 n

### 필요 개념
- [[ ]]

---

## ✏️ 풀이

### C++
```cpp
#include <algorithm>
#include <iostream>
#include <ranges>
#include <string>
#include <vector>

auto main() -> int {
  std::string s;
  if (std::cin >> s) {
    auto result =
        std::views::iota('a', static_cast<char>('z' + 1)) |
        // a - z까지의 연속 squence를 만듦. 보는 범위를 만드는 것.
        std::views::transform([&s](char c) { return (int)s.find(c); });
    // s를 참조,
    for (int i : result) {
      std::cout << i << " ";
    }
  }
  return 0;
}
```

### 복잡도
- 시간: O()
- 공간: O()

---

## 🔍 복기

### 맞았으면
- 핵심:
- 더 좋은 방법:

### 틀렸으면
- 실수:
- 정답:

---

## 📝 FC
#flashcards/coding

10809 핵심:: 

