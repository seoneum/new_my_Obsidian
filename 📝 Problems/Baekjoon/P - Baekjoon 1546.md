---
type: problem
title: P - 1546
created: 2026-01-22
updated: 2026-01-22T19:05:20
problem_type: coding
source: baekjoon
difficulty: easy
language: cpp
status: "[[🚜In Progress]]"
solved: false
tags:
  - problem
  - problem/coding
  - difficulty/easy
  - source/baekjoon
---
# 1546

> **coding** | 난이도: **easy** | 출처: baekjoon 1546

---

## 📋 문제

### 입력
```
평균을 재정의 해야함
((원점수 평균/최고점) * 100)의 공식을 함.
점수 n개 받음.
그럼 입력은 개수 설정 n, 점수 n개.
```

### 출력
```
저 공식을 적용한 새로운 평균
```

### 제한
- 시간: 
- 메모리: 

---

## 🧠 접근

### 첫 생각
- vector를 써서 하나의 배열에 집어넣자.
- 더블로 해서 소수점 자리로 상대오차를 잡자.
- algorithm header에 있는 ranges::sort(v)알고리즘 쓰자. 
- 그리고 ranges::max로 최대값 반환
- std::accumulate(시작, 끝, 시작 값) : 안을 다 더함

### 핵심 아이디어
- 내 생각엔 accumulate를 쓰는 것도 사실 어차피 for문 안에 있어서 딱히 상관없을 것 같은데.
- 잘 모르겠네 이번건
---
- 내가 몰랐네!!
- 이거 잘못됐음
-  

### 필요 개념
- [[ ]]
- std::ranges::sort()
- stdd::ranges::max()
- std::fixed << std::steprecision() : 소수점 고정. 
- std::accumulate (시작, 끝, 초기화 값) : 시작 - 끝까지 더하기
- 

---

## ✏️ 풀이

### C++
```cpp
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <numeric>
#include <ranges>
#include <vector>

auto main() -> int {
  std::cin.tie(nullptr)->sync_with_stdio(false);

  int n;
  //double sum = 0, avg;
  double avg;
  if (std::cin >> n) {
    std::vector<double> v(n);
    for (double &x : v) {
      std::cin >> x;
    }
    //std::ranges::sort(v);
	//사실 sort할 필요도 없음. 그냥 max찍으면 돼.
    double m = std::ranges::max(v);
    //for (auto _ : v) {
    //  sum = std::accumulate(v.begin(), v.end(), 0.0);
    //}
	double sum = std::accumulate(v.begin(), v.end(), 0.0);
    
    avg = (sum / m * 100) / n;
    std::cout << std::fixed << std::setprecision(6) << avg;
  }
  return 0;
}
```

### 복잡도
- 시간: O()
- 공간: O()

---

## 🔍 복기

### 맞았으면
- 핵심:
- 더 좋은 방법:
- fixed를 왜 해야할까? -> 안하면 그냥 과학 표기법으로 바꾸기 때문. 
- 대충 ai정리한 것을 넣자면
  
사용자님의 **"최적화와 효율성"** 에 대한 고민, 아주 훌륭한 개발자의 자세입니다! 👏

불필요한 `0000`을 출력하는 게 낭비처럼 느껴지는 건 당연한 직관입니다.

결론부터 말씀드리면:

1. **PS(알고리즘 문제 풀이)에서는:** 그냥 `fixed` 박고 넉넉하게 출력하는 게 **"정답 확률 최적화"**입니다. (출력 텍스트 몇 바이트 줄이는 것보다 안전빵이 중요함)
    
2. **실무/일반 개발에서는:** `fixed`를 끄면 됩니다.
    

상세하게 분석해 드릴게요.

---

### 1. 왜 "적당히"가 아니라 "과하게" 출력하라고 할까요? 🎯

문제에서 "오차 $10^{-2}$까지 허용"이라는 말은, **"네 답과 정답의 차이가 0.01 이내면 봐줄게"**라는 뜻입니다.

#### 시나리오: 정답이 `33.333333...` 인 경우

- **유저 A (딱 맞춰서 2자리 출력):** `33.33`
    
    - 오차: $|33.3333... - 33.33| = 0.0033...$ (통과 ✅)
        
- **유저 B (넉넉하게 6자리 출력):** `33.333333`
    
    - 오차: $|33.3333... - 33.333333| = 0.000000...$ (완벽 통과 ✅)
        

#### 시나리오: 정답이 `0.005` (반올림 경계) 인 경우 ⚠️

- **유저 A (2자리 반올림):** `0.01` (시스템에 따라 반올림 규칙이 미세하게 다를 수 있음)
    
    - 오차: $|0.005 - 0.01| = 0.005$ (위험함)
        
- **유저 B (6자리):** `0.005000`
    
    - 오차: **0** (안전함)
        

즉, 비트나 출력 바이트를 아끼려다 **"반올림 오차"** 때문에 틀릴 위험이 생깁니다. 채점 서버가 내 답을 어떻게 해석할지 모르니, **"정보를 최대한 많이 줘서 채점 서버가 알아서 판단하게 하는 것"**이 전략적으로 유리합니다.

---

### 2. "적당한 선"까지만 출력하는 법 (Adaptive) 📉

만약 이 문제가 아니라, 정말 필요한 만큼만 출력하고 싶다면 **`fixed`를 끄면 됩니다.**

`std::cout`의 기본 설정(`defaultfloat`)은 **"의미 있는 숫자(유효 숫자) 6개"**만 보여주고, 필요 없으면 뒷부분 0을 자릅니다.

C++

```
// 1. fixed를 끕니다 (기본 상태)
cout.unsetf(ios::fixed); 

// 2. 0.333333333... -> 0.333333 (6자리만 나옴)
// 3. 12.500000 -> 12.5 (뒤에 0 잘림! 원하시는 게 이거죠?)
cout << 12.5; 
```

**치명적인 단점 (PS에서 비추천하는 이유):**

숫자가 커지거나 작아지면 멋대로 **과학적 표기법($1.2e+05$)**으로 바꿔버립니다. 백준 채점기는 이걸 오답으로 처리할 수 있습니다.

---

### 3. 효율성 팩트 체크 (낭비일까?) 💾

"낭비되는 비트"를 걱정하셨는데, 실제로는 이렇습니다.

1. **메모리(RAM):** `double`은 출력하든 안 하든 무조건 **64비트(8바이트)**를 차지합니다. 출력 자릿수와 상관없습니다.
    
2. **출력(I/O) 속도:**
    
    - `33.33` (5글자) vs `33.333333` (9글자)
        
    - 4바이트 차이입니다.
        
    - 요즘 컴퓨터는 1초에 수억 번 연산합니다. 출력 4바이트 더 하는 건 **티끌조차 안 되는 시간(나노초 단위)**입니다.
        
    - **결론:** 최적화 효과는 **0**에 수렴합니다.
        

---

### 4. 결론: 이렇게 하세요

사용자님의 **"효율성 추구"** 마인드는 정말 좋지만, 이 문제(실수 오차)에서만큼은 **"투 머치(Too much)"** 가 정답입니다.

그냥 두시는 게(6자리 고정) 가장 좋습니다.

C++

```
// PS 국룰 세팅: 고민 비용을 없애줍니다.
cout << fixed << setprecision(6);
```

이 코드는 **"비효율"**이 아니라, 정답을 맞히기 위한 **"보험료"**라고 생각하시면 편합니다! 😉

### 틀렸으면
- 실수: 개념을 잘 몰라서 자꾸 실수하는 듯. 
- 정답:

---

## 📝 FC
#flashcards/coding

1546 핵심:: 

